const Discord = require('discord.js')
const DisTube = require('distube')
const path = require('path')
const ytdl = require('ytdl-core')
const fs = require('fs')
const {SoundCloudPlugin} = require('@distube/soundcloud')
const {SpotifyPlugin} = require('@distube/spotify')
const {token, prefix} = require('./config.json')
const { YouTubeDLPlugin } = require('distube')
const {CommandInteraction ,MessageEmbed, MessageActionRow, MessageButton, Client, Message} = require('discord.js')
const {pagination} = require('reconlx')

const client = new Discord.Client({
	intents: [
		'GUILDS',
		'GUILD_VOICE_STATES',
		'GUILD_MESSAGES',
		'GUILD_MESSAGE_REACTIONS',
	],
	partials: [
		'MESSAGE',
		'CHANNEL',
		'REACTION'
	]
})
sent = 0
const color = '1e75c7'
const COOKIE = 'VISITOR_INFO1_LIVE=-zLaXJYfqCM; PREF=tz=America.Chicago&f6=40000000&f5=30000; GPS=1; YSC=CEWGjo5VdtI; SID=CAiuMMsrfOsi_JTBGp18aALFhcQsqWcj1vDPzoD2-aruv-u7Cw42hhj0OAaUyAXDzX8u1Q.; __Secure-1PSID=CAiuMMsrfOsi_JTBGp18aALFhcQsqWcj1vDPzoD2-aruv-u7FdvBGj7PKr-t02nL61LouA.; __Secure-3PSID=CAiuMMsrfOsi_JTBGp18aALFhcQsqWcj1vDPzoD2-aruv-u7QW-1h87CNT8uRDaE7GLomw.; HSID=AbdtiF8zSQT7a99tr; SSID=APPxTXZi8nXZGnbfE; APISID=OQ88pQnbY_nha1C9/Avgg8VPa-QQyMQ8Tz; SAPISID=CyO2GPehuAwomBKi/AMSIZaeu7mzGlaT9L; __Secure-1PAPISID=CyO2GPehuAwomBKi/AMSIZaeu7mzGlaT9L; __Secure-3PAPISID=CyO2GPehuAwomBKi/AMSIZaeu7mzGlaT9L; LOGIN_INFO=AFmmF2swRQIhANh9uTA37ZgeVBvBLh83D3Dk2pLIDDUfCQL-iWJwZej8AiAzVD95iyfBjxbgtiLMeDiGOsX2oAZLdJbBDvylJxkDrQ:QUQ3MjNmeDV6bF9jSmlFUm1jVjluU0FMWExOZEpxajNzbjdYTzNtQkU3bXc2dEFZd2hXdGJBVmRTVGI3VVhwMDc0aHZoODFyTHJYdWdtVnZWVVc0N0dta3oxamhDSDk5eHQtazFhLVJLVkI2bTlDRVdJMUNad3VHaXNXR2JieGFQeWliMW8wV3BkbVgzdEhIRGY3TVl2Y3FvYy14eFV4cTlR; SIDCC=AJi4QfGIhI6f7DvDFN8OnEw6UXqufonJcaNQgoZQ4F9CuZIrK8nTPjsrbZ951LIRduY9OJHb; __Secure-3PSIDCC=AJi4QfG-h_ly7M_fjNpzk-yXXM45BEsVSsnUCL8m3VIVgIcKGzXtGFG1PTtDzn90qIyMhh_yWA'

const distube = new DisTube.default(client, {
	searchSongs: 6,
	searchCooldown: 30,
	leaveOnEmpty: true,
	emptyCooldown: 5,
	leaveOnFinish: false,
	leaveOnStop: true,
    nsfw: true,
	youtubeCookie: COOKIE,
	plugins: [new SoundCloudPlugin(), new SpotifyPlugin()],
})

client.once('ready', () => 
{
	console.log(`Logged in as ${client.user.tag}!`)
    client.user.setActivity('It\'s a cuddle party! Listening to -help')
})

client.on('messageCreate', async message => 
{
    if(!message.content.startsWith(prefix) || message.author.bot || message.channel.type === 'dm') return

	const args = message.content.slice(prefix.length).trim().split(' ')
    const command = args.shift().toLowerCase()

	if (command.length === 0)
	{
		return
	}
	
	if (command === 'help')
	{
		message.delete().catch(console.error)
		const exampleEmbed = new MessageEmbed()
		.setColor(color)
		//.setTitle('Some title')
		.setAuthor('Help Menu', 'https://cdn.discordapp.com/attachments/328391017403252737/890151465648271391/cuddleco.png')
		//.setDescription('Some description here')
		//.setThumbnail('https://cdn.discordapp.com/attachments/328391017403252737/890151510422482974/doge.png')
		.addFields(
			{ name: 'Media commands', value: '\`help\`, \`play`\, \`qplay\`, \`stop\`, \`skip\`, \`queue\`, \`volume\`, \`fastforward\`, \`rewind`\ , \`repeat\`, \`loop\`'},
			//{ name: '\u200B', value: '\u200B' },
			{ name: 'Effect commands', value: '\`3d\`, \`bassboost`\, \`echo`\, \`karaoke`\, \`nightcore`\, \`vaporwave\`, \`reset\`'},
			//{ name: 'Inline field title', value: 'Some value here', inline: true },
		)
		//.addField('Inline field title', 'Some value here', true)
		//.setTimestamp()
		//.setFooter('Cuddle Wuddle', 'https://cdn.discordapp.com/attachments/328391017403252737/890151465648271391/cuddleco.png');
		.setFooter(`Prefix is ${prefix}`)
		message.channel.send({ embeds: [exampleEmbed] })
		return
	}

    if(!message.member.voice.channel) return message.channel.send('You must be in a voice channel to use this command.')
	.then(msg =>
		{
			setTimeout(() => msg.delete().catch(console.error), 10000)
		})

	if (command === 'play' || command === 'p') 
	{
		//message.channel.send({embeds: [exampleEmbed]})
		await distube.voices.join(message.member.voice.channel)
		distube.options.searchSongs = 6
		await distube.play(message, args.join(" ")).catch(console.error)
		return
	}

	if (command === 'qplay' || command === 'qp')
	{
		await distube.voices.join(message.member.voice.channel)
		distube.options.searchSongs = 1
		await distube.play(message, args.join(" ")).catch(console.error)
		return
	}

    if(['repeat', 'loop'].includes(command)) 
    {
        let queue = distube.getQueue(message);

        if(queue) {
			const mode = distube.setRepeatMode(message)
			message.channel.send(`Set repeat mode to \`${mode ? mode === 2 ? 'All Queue' : 'This Song' : 'Off'}\``)
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), 10000)
				})
			message.delete().catch(console.error)
        } 
        else if (!queue) {
            message.channel.send('Nothing in the queue!')
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), 10000)
				})
			message.delete().catch(console.error)
            return
        }
    }

	if (command === 'stop') {
        let queue = distube.getQueue(message);

        if(queue) {
            distube.stop(message).catch(console.error)
            message.channel.send('Stopped the music!')
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), 10000)
				})
			message.delete().catch(console.error)
        } 
        else if (!queue) {
            message.channel.send('Nothing in the queue!')
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), 10000)
				})
			message.delete().catch(console.error)
            return
        }
	}


	if (command === 'resume') {
        let queue = distube.getQueue(message);

        if(queue) {
            distube.resume(message).catch(console.error)
            message.channel.send('Resumed the song!')
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), 10000)
				})
			message.delete().catch(console.error)	
        } 
        else if (!queue) {
            message.channel.send('Nothing in the queue!')
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), 10000)
				})
			message.delete().catch(console.error)
            return
        }
	}

	if (command === 'pause') {
        let queue = distube.getQueue(message);

        if(queue) {
            distube.pause(message).catch(console.error)
            message.channel.send('Paused the song!')
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), 10000)
				})
			message.delete().catch(console.error)
        } 
        else if (!queue) {
            message.channel.send('Nothing in the queue!')
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), 10000)
				})
			message.delete().catch(console.error)
            return
        }
	}

	if (command === 'skip' || command === 's') {
        let queue = distube.getQueue(message);

        if(queue && queue.songs.length > 1) {
            distube.skip(message)
            message.channel.send('Skipped the track!')
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), 10000)
				})
			message.delete().catch(console.error)
        } 
		else if (queue && queue.songs.length === 1){
			distube.stop(message)
			message.delete().catch(console.error)
		}
        else if (!queue) {
            message.channel.send('Nothing in the queue!')
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), 10000)
				})
			message.delete().catch(console.error)
            return
        }
	}

	if (command === 'queue' || command === 'q') {
		const queue = distube.getQueue(message)
		if (!queue) {
			message.channel.send('Nothing in the queue!')
			message.delete().catch(console.error)
		} 
		else 
		{
			/*let curqueue = queue.songs.map((song, id) =>
			`**${id + 1}**. ${song.name} - \`${song.formattedDuration}\``
			).join("\n");

			const exampleEmbed = new MessageEmbed()
			.setColor('#c27345')
			.addField(`Current Queue`, `${curqueue}`)
			message.channel.send({ embeds: [exampleEmbed] })
			.then(msg =>
			{
					setTimeout(() => msg.delete().catch(console.error), 15000)
			})*/

			let embedArray = []
			let k = 10
			for(let i = 0; i < queue.songs.length; i += 10)
			{
				const current = queue.songs.slice(i, k)
				let j = i
				k += 10
				const info = current.map(song => `**${++j}**. [${song.name}](${song.url})`).join('\n')
				const embed = new MessageEmbed()
					.setColor(color)
					.setDescription(`**[Current Song: ${queue.songs[0].name}](${queue.songs[0].url})**\n${info}`)
					embedArray.push(embed)
			}

			pagination
			({
				embeds: embedArray,
				channel: message.channel,
				author: message.author,
				time: 20000,
				fastSkip: true,
			}).catch(console.error)
		}
	}

    if (command === 'volume' || command === 'v') 
	{
		const queue = distube.getQueue(message)
		if (!queue)
		{
			message.channel.send(`There is nothing in the queue right now!`)
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), 10000)
				})
			message.delete().catch(console.error)
			return
		}
		volume = parseInt(args[0])
		if (isNaN(volume))
		{
			message.channel.send(`Please enter a valid number!`)
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), 10000)
				})
			message.delete().catch(console.error)
			return 
		}
		if (volume < 1) return volume = 1
		else if (volume > 250)
		{
			message.channel.send('Value has to be between 1 and 250!')
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), 10000)
				})
			message.delete().catch(console.error)
			return
		}
		
		distube.setVolume(message, volume)
		const embed = new MessageEmbed()
			.setColor(color)
			.setDescription(`Volume set to \`${volume}\``)

			message.channel.send({ embeds: [embed] })
		.then(msg =>
			{
				setTimeout(() => msg.delete().catch(console.error), 10000)
			})
		message.delete().catch(console.error)
		return
	}

    if(command === 'reset'|| command === 'r')
    {
        let queue = distube.getQueue(message) 
        if(queue)
        {
            const filter = distube.setFilter(message, false)
            message.channel.send(
                `Current queue filter: ${filter.join(', ') || 'Off'}`,
            ).then(msg =>
			{
				setTimeout(() => msg.delete().catch(console.error), 10000)
			})
			message.delete().catch(console.error)
        }
        else if (!queue) {
            message.channel.send('I must be playing a song to change the reset the filter!')
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), 10000)
				})
			message.delete().catch(console.error)
            return
        }
    }

	if(command === 'ff' || command === 'fastforward')
	{
        let queue = distube.getQueue(message) 
		if(queue && args[0])
		{
			var p = args[0].split(':')
			for(let i = 0 ; i < p.length ; i++)
				var num = parseInt(p[i])
				if (isNaN(num) || num < 0)
				{
					const exampleEmbed = new MessageEmbed()
						.setColor(color)
						.setDescription(`Time has to be in \`HH:MM:SS\` | \`MM:SS\` | \`SS\` format!`)
					message.channel.send({ embeds: [exampleEmbed] })
					.then(msg =>
						{
							setTimeout(() => msg.delete().catch(console.error), 10000)
						})
					message.delete().catch(console.error)
					return 
				}

			s = 0
			m = 1

			while (p.length > 0) 
			{
				s += m * parseInt(p.pop(), 10);
				m *= 60;
			}

			distube.seek(message, queue.currentTime + s)

			const exampleEmbed = new MessageEmbed()
				.setColor(color)
				.setDescription(`Time set to \`${queue.formattedCurrentTime}\` for [${queue.songs[0].name}](${queue.songs[0].url})`)
			queue.textChannel.send({ embeds: [exampleEmbed] })
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), 10000)
				})

			return
		}

        else if (!queue) 
		{
            message.channel.send('Nothing in the queue!')
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), 10000)
				})
			message.delete().catch(console.error)
            return
        }

	}

	if(command === 'rw' || command === 'rewind')
	{
        let queue = distube.getQueue(message) 
		if(queue && args[0])
		{
			var p = args[0].split(':')
			for(let i = 0 ; i < p.length ; i++)
				var num = parseInt(p[i])
				if (isNaN(num) || num < 0)
				{
					const exampleEmbed = new MessageEmbed()
						.setColor(color)
						.setDescription(`Time has to be in \`HH:MM:SS\` | \`MM:SS\` | \`SS\` format!`)
					message.channel.send({ embeds: [exampleEmbed] })
					.then(msg =>
						{
							setTimeout(() => msg.delete().catch(console.error), 10000)
						})
					message.delete().catch(console.error)
					return 
				}

			s = 0
			m = 1

			while (p.length > 0) 
			{
				s += m * parseInt(p.pop(), 10);
				m *= 60;
			}

			if(queue.currentTime - s < 0)
			{
				distube.seek(message, 0)
				const exampleEmbed = new MessageEmbed()
				.setColor(color)
				.setDescription(`Time set to \`${queue.formattedCurrentTime}\` for [${queue.songs[0].name}](${queue.songs[0].url})`)
				queue.textChannel.send({ embeds: [exampleEmbed] })
				.then(msg =>
					{
						setTimeout(() => msg.delete().catch(console.error), 10000)
					})

				return
			}

			distube.seek(message, queue.currentTime - s)

			const exampleEmbed = new MessageEmbed()
				.setColor(color)
				.setDescription(`Time set to \`${queue.formattedCurrentTime}\` for [${queue.songs[0].name}](${queue.songs[0].url})`)
			queue.textChannel.send({ embeds: [exampleEmbed] })
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), 10000)
				})

			return
		}

        else if (!queue) 
		{
            message.channel.send('Nothing in the queue!')
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), 10000)
				})
			message.delete().catch(console.error)
            return
        }

	}

	if (
		[
			`3d`,
			`bassboost`,
			`echo`,
			`karaoke`,
			`nightcore`,
			`vaporwave`,
		].includes(command)
	) {
        let queue = distube.getQueue(message) 
        if(queue)
        {
            const filter = distube.setFilter(message, command)
            message.channel.send(
                `Current queue filter: ${filter.join(', ') || 'Off'}`,
				).then(msg =>
					{
						setTimeout(() => msg.delete().catch(console.error), 10000)
					})
					message.delete().catch(console.error)
        }
        else if (!queue) {
            message.channel.send('I must be playing a song to change the filter!')
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), 10000)
				})
			message.delete().catch(console.error)
            return
        }
	}
})

const status = queue =>
	`Volume: \`${queue.volume}%\` | Filter: \`${queue.filters.join(', ')
		|| 'Off'}\` | Loop: \`${
		queue.repeatMode
			? queue.repeatMode === 2
				? 'All Queue'
				: 'This Song'
			: 'Off'
	}\` | Autoplay: \`${queue.autoplay ? 'On' : 'Off'}\``

distube
	.on('playSong', async (queue, song) =>
	{
		if(sent != 0)
		{
			try{
			queue.textChannel.messages.fetch(sent.id).then(msg => msg.delete().catch(console.log)).catch(console.log)
			} catch {console.error}
		}

		const exampleEmbed = new MessageEmbed()
		.setColor(color)
		.addField('Now Playing', `${song.name} - \`${song.formattedDuration}\``)
		sent = await queue.textChannel.send({ embeds: [exampleEmbed] })
	})
	.on('finishSong', (queue, song) => 
	{
		if(sent != 0)
		{
			queue.textChannel.messages.fetch(sent.id).then(msg => msg.delete().catch(console.log)).catch(console.log)
		}
	})
	.on('disconnect', (queue) =>
	{
		if(sent != 0)
		{
			queue.textChannel.messages.fetch(sent.id).then(msg => msg.delete().catch(console.log)).catch(console.log)
		}
	})
	.on('addSong', (queue, song) =>
	{
		const position = queue.songs.length
		if(position > 1)
		{
			const exampleEmbed = new MessageEmbed()
			.setColor(color)
			.addField(`Track Queue - Position ${position}`, `${song.name} - \`${song.formattedDuration}\``)
			queue.textChannel.send({ embeds: [exampleEmbed] })
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), song.duration * 1000)
				})
		}
		else
		{
			const exampleEmbed = new MessageEmbed()
			.setColor(color)
			.addField('Added', `${song.name} - \`${song.formattedDuration}\``)
			queue.textChannel.send({ embeds: [exampleEmbed] })
			.then(msg =>
				{
					setTimeout(() => msg.delete().catch(console.error), song.duration * 1000)
				})
		}
	})
	.on('addList', (queue, playlist) =>
		queue.textChannel.send(
			`Added \`${playlist.name}\` playlist (${
				playlist.songs.length
			} songs) to queue`,
		))
	// DisTubeOptions.searchSongs = true
	.on('searchResult', (message, result) => 
	{
		let i = 0
		const one = '1️⃣'
		const two = '2️⃣'
		const three = '3️⃣'
		const four = '4️⃣'
		const five = '5️⃣'
		const six = '6️⃣'
		let emojis = [one,two,three,four,five,six]

		//const testRole = message.guild.roles.cache.find(role => role.name === 'Test Role')

		const exampleEmbed = new MessageEmbed()
		.setColor(color)
		//.setTitle('Some title')
		.setAuthor('Search Menu', 'https://cdn.discordapp.com/attachments/328391017403252737/890151465648271391/cuddleco.png')
		//.setDescription('Some description here')
		//.setThumbnail('https://cdn.discordapp.com/attachments/328391017403252737/890151510422482974/doge.png')
		.addFields(
			{ name: 'Songs', value: `\n${result.map(song => `${emojis[i++]} ${song.name} - \`${song.formattedDuration}\``).join("\n\n")}\n\n*React to a number or wait 30 secconds to cancel*`},
			//{ name: '\u200B', value: '\u200B' },
			//{ name: 'Inline field title', value: 'Some value here', inline: true },
		)
		message.channel.send({ embeds: [exampleEmbed] }).then(msg => 
		{
			setTimeout(() => msg.delete().catch(console.error), 30000)
			msg.react('1️⃣').catch(console.error)
			msg.react('2️⃣').catch(console.error)
			msg.react('3️⃣').catch(console.error)
			msg.react('4️⃣').catch(console.error)
			msg.react('5️⃣').catch(console.error)
			msg.react('6️⃣').catch(console.error)
			client.on('messageReactionAdd', async (reaction, user) =>
			{
				if(reaction.message.partial) await reaction.message.fetch()
				if(reaction.partial) await reaction.fetch()
				if(user.bot) return
				if(!reaction.message.guild) return

				if(reaction.message.id == msg.id && message.member.voice.channel)
				{
					let queue = distube.getQueue(message);
					if(reaction.emoji.name === one)
					{
						i = 0
						distube.play(message, result[i].url)
						msg.delete().catch(console.error)
						message.delete().catch(console.error)
					}
					else if(reaction.emoji.name === two)
					{
						i = 1
						distube.play(message, result[i].url)
						msg.delete().catch(console.error)
						message.delete().catch(console.error)
					}
					else if(reaction.emoji.name === three)
					{
						i = 2
						distube.play(message, result[i].url)
						msg.delete().catch(console.error)
						message.delete().catch(console.error)
					}
					else if(reaction.emoji.name === four)
					{
						i = 3
						distube.play(message, result[i].url)
						msg.delete().catch(console.error)
						message.delete().catch(console.error)
					}
					else if(reaction.emoji.name === five)
					{
						i = 4
						distube.play(message, result[i].url)
						msg.delete().catch(console.error)
						message.delete().catch(console.error)
					}
					else if(reaction.emoji.name === six)
					{
						i = 5
						distube.play(message, result[i].url)
						msg.delete().catch(console.error)
						message.delete().catch(console.error)
					}
				}
				else
				{
					return
				}
			})
		})
	})

	// DisTubeOptions.searchSongs = true
	.on('searchCancel', message => 
	{
		message.delete().catch(console.error)
	})
	.on('searchInvalidAnswer', message =>
	{
	})

	.on('searchNoResult', message => message.channel.send(`No result found!`))
	.on('searchDone', (message, answer, query) =>
	{
		message.delete().catch(console.error)
		answer.delete().catch(console.error)
	})
	.on('error', (textChannel, e) => {
		console.error(e)
		if (e.isArrray)
		{
			textChannel.send(`An error encountered: \`${e.slice(0, 2000)}\``)
		}
		else
		{
			textChannel.send(`An error encountered: \`${e}\``)
		}
	})

client.login(token)